package data

/*
  Onix Config Manager - Artisan
  Copyright (c) 2018-2021 by www.gatblau.org
  Licensed under the Apache License, Version 2.0 at http://www.apache.org/licenses/LICENSE-2.0
  Contributors to this project, hereby assign copyright in this code to the project,
  to be licensed under the same terms as the rest of the code.
*/
import (
	"bytes"
	"fmt"
	"strings"
	"time"
)

type Manifest struct {
	// the package type
	Type string `json:"type,omitempty"`
	// the license associated to the package
	License string `json:"license"`
	// the target OS for the package
	OS string `json:"os"`
	// the name of the package file
	Ref string `json:"ref"`
	// the build profile used
	Profile string `json:"profile"`
	// runtime image that should be used to execute exported functions in the package
	Runtime string `json:"runtime"`
	// the labels assigned to the package
	Labels map[string]string `json:"labels,omitempty"`
	// the URI of the package source
	Source string `json:"source,omitempty"`
	// the path within the source where the project is (for uber repos)
	SourcePath string `json:"source_path,omitempty"`
	// the commit hash
	Commit string `json:"commit,omitempty"`
	// repo branch
	Branch string `json:"branch,omitempty"`
	// repo tag
	Tag string `json:"tag,omitempty"`
	// the name of the file or folder that has been packaged
	Target string `json:"target,omitempty"`
	// the timestamp
	Time string `json:"time"`
	// the size of the package
	Size string `json:"size"`
	// true if the target was zipped previous to packaging (e.g. jar files)
	Zip bool `json:"zip"`
	// what functions are available to call?
	Functions []*FxInfo `json:"functions,omitempty"`
}

func (m Manifest) Fx(name string) *FxInfo {
	for _, fx := range m.Functions {
		if fx.Name == name {
			return fx
		}
	}
	return nil
}

// exported function list
type FxInfo struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	Input       *Input `json:"input,omitempty"`
	// runtime image that should be used to execute functions in the package
	Runtime string `json:"runtime,omitempty"`
}

func (m *Manifest) ToMarkDownBytes(name string) []byte {
	var b bytes.Buffer
	b.WriteString(fmt.Sprintf("# Package %s Manifest\n", name))
	b.WriteString(fmt.Sprintf("*autogenerated using [Artisan CLI](https://github.com/gatblau/artisan) on %s*\n", time.Now().Format(time.RFC822Z)))
	for _, fx := range m.Functions {
		b.WriteString(fmt.Sprintf("## Function: %s\n", fx.Name))
		b.WriteString(fmt.Sprintf("%s\n", fx.Description))
		if len(fx.Input.Var) > 0 {
			b.WriteString(fmt.Sprintf("### Variables:\n"))
			b.WriteString(fmt.Sprintf("|name|description|default|\n"))
			b.WriteString(fmt.Sprintf("|---|---|---|\n"))
			for _, v := range fx.Input.Var {
				b.WriteString(fmt.Sprintf("|%s|%s|%s|\n", v.Name, format(v.Description), v.Default))
			}
		}
		if len(fx.Input.Secret) > 0 {
			b.WriteString(fmt.Sprintf("### Secrets:\n"))
			b.WriteString(fmt.Sprintf("|name|description|\n"))
			b.WriteString(fmt.Sprintf("|---|---|\n"))
			for _, s := range fx.Input.Secret {
				b.WriteString(fmt.Sprintf("|%s|%s|\n", s.Name, format(s.Description)))
			}
		}
		if len(fx.Input.Key) > 0 {
			b.WriteString(fmt.Sprintf("### Keys:\n"))
			b.WriteString(fmt.Sprintf("|name|description|private|\n"))
			b.WriteString(fmt.Sprintf("|---|---|---|\n"))
			for _, k := range fx.Input.Key {
				b.WriteString(fmt.Sprintf("|%s|%s|%t|\n", k.Name, format(k.Description), k.Private))
			}
		}
		if len(fx.Input.File) > 0 {
			b.WriteString(fmt.Sprintf("### Files:\n"))
			b.WriteString(fmt.Sprintf("|name|description|path|\n"))
			b.WriteString(fmt.Sprintf("|---|---|---|\n"))
			for _, f := range fx.Input.File {
				b.WriteString(fmt.Sprintf("|%s|%s|%s|\n", f.Name, format(f.Description), f.Path))
			}
		}
	}
	return b.Bytes()
}

func format(content string) string {
	return strings.Replace(content, "\n", "<br>", -1)
}
